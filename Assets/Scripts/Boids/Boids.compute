// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float3 position;
    float3 velocity;
};

float moveSpeed;
float turnSpeed;

bool isAlignmentEnabled;
float alignmentRadius;
float alignmentWeight;

bool isCohesionEnabled;
float cohesionRadius;
float cohesionWeight;

bool isSeparationEnabled;
float separationRadius;
float separationWeight;

float boundsRadius;
float boundsTurnSpeed;

RWStructuredBuffer<Boid> boidsBuffer;
int boidsCount;

float deltaTime;

[numthreads(256, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= boidsCount) return;
    
    Boid self = boidsBuffer[id.x];

    float3 alignmentForce = float3(0, 0, 0);
    float3 cohesionForce = float3(0, 0, 0);
    float3 separationForce = float3(0, 0, 0);

    int alignmentCount = 0;
    int cohesionCount = 0;
    int separationCount = 0;

    for (int i = 0; i < boidsCount; i++)
    {
        if (i == id.x) continue;

        Boid other = boidsBuffer[i];
        float dist = distance(self.position, other.position);

        if (isAlignmentEnabled && dist < alignmentRadius)
        {
            alignmentForce += other.velocity;
            alignmentCount++;
        }

        if (isCohesionEnabled && dist < cohesionRadius)
        {
            cohesionForce += other.position;
            cohesionCount++;
        }

        if (isSeparationEnabled && dist < separationRadius)
        {
            float3 repulsion = normalize(self.position - other.position);
            float separationStrength = separationWeight / max(dist, 0.01); // avoid division by zero!
            separationForce += repulsion * separationStrength;
            separationCount++;
        }
    }

    if (alignmentCount > 0)
    {
        alignmentForce /= alignmentCount;
        alignmentForce = normalize(alignmentForce) * alignmentWeight;
    }

    if (cohesionCount > 0)
    {
        float3 centerOfMass = cohesionForce / cohesionCount;
        cohesionForce = normalize(centerOfMass - self.position) * cohesionWeight;
    }

    float3 totalForce = float3(0, 0, 0);
    if (isAlignmentEnabled) totalForce += alignmentForce;
    if (isCohesionEnabled) totalForce += cohesionForce;
    if (isSeparationEnabled) totalForce += separationForce;
    
    float3 center = float3(0, 0, 0);
    float distFromCenter = length(self.position);

    if (distFromCenter > boundsRadius)
    {
        float3 toCenter = normalize(center - self.position);
        self.velocity = lerp(self.velocity, toCenter * length(self.velocity), boundsTurnSpeed * deltaTime);
    }

    self.velocity += totalForce * deltaTime;
    float speed = length(self.velocity);
    if (speed > moveSpeed)
        self.velocity = normalize(self.velocity) * moveSpeed;
    self.position += self.velocity * deltaTime;

    
    boidsBuffer[id.x] = self;
}
